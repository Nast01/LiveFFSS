import 'package:intl/intl.dart';
import 'package:live_ffss/app/core/const/format_const.dart';
import 'package:live_ffss/app/data/models/slot_model.dart';

class MeetingModel {
  late int id;
  late String name;
  late String description;
  late DateTime date;
  late DateTime beginHour;
  late DateTime endHour;
  late List<SlotModel> slots;

  MeetingModel({
    required this.id,
    required this.name,
    required this.description,
    required this.date,
    required this.beginHour,
    required this.endHour,
  });

  factory MeetingModel.fromJson(Map<String, dynamic> json) {
    final dateFormat = FormatConst.dateFormat;
    final timeFormat = FormatConst.timeFormat;

    final parsedDate = dateFormat.parse(json["Jour"]);
    // Parse begin and end times and combine with date
    final beginTime = timeFormat.parse(json["Debut"]);
    final endTime = timeFormat.parse(json["Fin"]);

    final beginDateTime = DateTime(
      parsedDate.year,
      parsedDate.month,
      parsedDate.day,
      beginTime.hour,
      beginTime.minute,
    );

    final endDateTime = DateTime(
      parsedDate.year,
      parsedDate.month,
      parsedDate.day,
      endTime.hour,
      endTime.minute,
    );

    MeetingModel meeting = MeetingModel(
      id: json["Id"],
      name: json["Nom"],
      description: json["Description"],
      date: parsedDate,
      beginHour: beginDateTime,
      endHour: endDateTime,
    );

    if (json['creneaus'] != null) {
      meeting.slots = (json['creneaus'] as List<dynamic>)
          .map((slot) => SlotModel.fromJson(slot, meeting))
          .toList();

      // Sort slots by beginHour
      meeting.slots.sort((a, b) => a.beginHour.compareTo(b.beginHour));
    } else {
      meeting.slots = [];
    }
    return meeting;
  }

  Map<String, dynamic> toJson() {
    final dateFormat = FormatConst.dateFormat;
    final timeFormat = FormatConst.timeFormat;

    return {
      "id": id, // Assuming id is auto-generated by the server
      "nom": name,
      "description": description,
      "jour": dateFormat.format(date),
      "debut": timeFormat.format(beginHour),
      "fin": timeFormat.format(endHour),
    };
  }

  Map<String, dynamic> toApiParams() {
    final dateFormat = FormatConst.dateFormat;
    final timeFormat = FormatConst.timeFormat;

    final params = <String, dynamic>{
      'nom': name,
      'description': description,
      "jour": dateFormat.format(date),
      "debut": timeFormat.format(beginHour),
      "fin": timeFormat.format(endHour),
    };

    // Only include ID if it's not 0 (for updates, not for creation)
    if (id != 0) {
      params['id'] = id.toString();
    } else {
      params['id'] = ''; // Ensure ID is not included for creation
    }

    return params;
  }

  // Helper method to format date for display
  String get formattedDate {
    return DateFormat('dd/MM/yyyy').format(date);
  }

  String get formattedDateMonth => DateFormat('MMM').format(date).toUpperCase();

  // Helper method to format begin time for display
  String get formattedBeginTime {
    return DateFormat('HH:mm').format(beginHour);
  }

  // Helper method to format end time for display
  String get formattedEndTime {
    return DateFormat('HH:mm').format(endHour);
  }

  // Helper method to get duration
  Duration get duration {
    return endHour.difference(beginHour);
  }

  // Helper method to format duration
  String get formattedDuration {
    final duration = this.duration;
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;

    if (hours > 0) {
      return '${hours}h ${minutes}min';
    } else {
      return '${minutes}min';
    }
  }
}
